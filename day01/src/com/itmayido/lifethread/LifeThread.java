package com.itmayido.lifethread;

/**
 * @AUTHOR LZG
 * @DATE 2020/12/19 14:29
 * @VERSION 1.0
 */

/**
 * 多线程的运行状态
 *
 * 1. 新建状态
 *          new Thread(),此时程序还没有开始运行线程中的代码
 *
 * 2. 就绪状态
 *          thread.start()
 *          一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，
 *          start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。
 *          处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。
 *          因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。
 *          对多个处于就绪状态的线程是由Java运行时系统的线程调度程序(thread scheduler)来调度的。
 *
 *  3.运行状态
 *          当线程获得cpu的执行权之后，它才进入运行状态，真正的开始执行run() 方法
 *
 *  4. 阻塞状态
 *          导致原因
 *          1>线程通sleep方法进入休眠状态
 *          2>线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者
 *          3>线程试图得到一个锁，而该锁正被其他线程所持有
 *          4>线程在等待某个出发条件
 *
 *  5. 死亡状态
 *      1>run()方法正常退出而死亡
 *      2>thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。
 *          比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B
 *
 */
public class LifeThread {
}
